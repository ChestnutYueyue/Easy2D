# Easy2D ANI 专业动画系统集成方案（融合 Cocos 设计优势）

## 一、架构总览 - 六层架构

借鉴 Cocos 的 **数据与行为分离** + **SpriteFrame 中间抽象** + **全局缓存** 三大核心模式，
同时保留 ANI 的 **Flag 不固定数据系统** 和 **ALS 复合动画** 独有优势。

```
+---------------------------------------------------------------------+
|  第6层：组件层  AnimationNode : Node / CompositeAnimation            |
|              面向用户的顶层API，挂载到场景图                           |
+---------------------------------------------------------------------+
|  第5层：事件层  AnimationEvent / AnimationEventType                   |
|              帧事件、关键帧回调、完成通知                               |
+---------------------------------------------------------------------+
|  第4层：渲染层  FrameRenderer（单Sprite纹理切换策略）                  |
|              混合模式映射、帧渲染                                      |
+---------------------------------------------------------------------+
|  第3层：控制层  AnimationController / InterpolationEngine             |
|              播放状态机、帧推进、插值计算                               |
+---------------------------------------------------------------------+
|  第2层：缓存层  AnimationCache / SpriteFrameCache    ← Cocos 借鉴    |
|              动画数据缓存、精灵帧全局管理                               |
+---------------------------------------------------------------------+
|  第1层：数据层  AnimationClip / AnimationFrame / SpriteFrame          |
|              FrameProperty / AniParser / AlsParser                   |
+---------------------------------------------------------------------+
```

### 与 Cocos 的对应关系
| Easy2D 新设计 | Cocos2d-x 对应 | Cocos Creator 对应 |
|--------------|----------------|-------------------|
| AnimationClip | Animation | AnimationClip |
| AnimationController | Animate (Action) | AnimationState |
| AnimationNode | Sprite + runAction | AnimationComponent |
| SpriteFrame | SpriteFrame | SpriteFrame |
| SpriteFrameCache | SpriteFrameCache | SpriteFrame资源管理 |
| AnimationCache | AnimationCache | AssetManager |
| FramePropertySet | — (Cocos无此概念) | 属性轨道(简化版) |

## 二、文件结构

### 头文件 `Easy2D/include/easy2d/animation/`
```
sprite_frame.h              // ★新增 SpriteFrame 中间抽象层（借鉴 Cocos）
sprite_frame_cache.h        // ★新增 SpriteFrame 全局缓存（借鉴 Cocos）
animation_cache.h           // ★新增 AnimationClip 全局缓存（借鉴 Cocos）
frame_property.h            // 类型安全的帧属性系统（ANI Flag 改进）
animation_frame.h           // 单帧数据结构
animation_clip.h            // 动画片段（帧序列，纯数据，可复用）
ani_parser.h                // ANI 文件解析器
als_parser.h                // ALS 复合动画解析器
animation_controller.h      // 播放控制器（状态机）
interpolation_engine.h      // 帧间插值引擎
frame_renderer.h            // 帧渲染策略
animation_event.h           // 动画事件定义
animation_node.h            // AnimationNode 场景节点
composite_animation.h       // ALS 多层复合动画节点
```

### 源文件 `Easy2D/src/animation/`（新建目录）
对应每个头文件的 `.cpp` 实现（共14对，28个文件）

## 三、分层详细设计

---

### 第1层 - 数据层

#### 3.1 `sprite_frame.h` - 精灵帧中间抽象层 ★借鉴 Cocos 核心设计

**为什么需要 SpriteFrame？**
原始 ANI 系统直接用路径+索引引用图片，每帧创建一个 Sprite 对象。
Cocos 的 SpriteFrame 是纹理和帧之间的**中间抽象层**，解耦了纹理物理存储和逻辑帧。

```cpp
// Easy2D/include/easy2d/animation/sprite_frame.h
#pragma once
#include <easy2d/core/types.h>
#include <easy2d/core/math_types.h>
#include <easy2d/graphics/texture.h>
#include <string>

namespace easy2d {

// ============================================================================
// SpriteFrame - 精灵帧（纹理 + 区域 + 偏移的中间抽象）
// 借鉴 Cocos2d-x SpriteFrame：解耦纹理物理存储与逻辑帧
// ============================================================================
class SpriteFrame {
public:
    SpriteFrame();
    SpriteFrame(Ptr<Texture> texture, const Rect& rect);
    SpriteFrame(Ptr<Texture> texture, const Rect& rect,
                const Vec2& offset, const Size& originalSize);

    // ------ 静态创建 ------
    static Ptr<SpriteFrame> create(Ptr<Texture> texture, const Rect& rect);
    static Ptr<SpriteFrame> create(Ptr<Texture> texture, const Rect& rect,
                                    const Vec2& offset, const Size& originalSize);

    // ------ 纹理信息 ------
    void setTexture(Ptr<Texture> texture);
    Ptr<Texture> getTexture() const { return texture_; }

    // ------ 矩形区域（在纹理图集中的位置）------
    void setRect(const Rect& rect);
    const Rect& getRect() const { return rect_; }

    // ------ 偏移（图集打包时的裁剪偏移）------
    void setOffset(const Vec2& offset);
    const Vec2& getOffset() const { return offset_; }

    // ------ 原始尺寸（裁剪前的完整尺寸）------
    void setOriginalSize(const Size& size);
    const Size& getOriginalSize() const { return originalSize_; }

    // ------ 旋转标志（图集工具可能旋转90度）------
    void setRotated(bool rotated);
    bool isRotated() const { return rotated_; }

    // ------ 名称（用于缓存索引）------
    void setName(const std::string& name) { name_ = name; }
    const std::string& getName() const { return name_; }

    // ------ 有效性检查 ------
    bool isValid() const { return texture_ != nullptr; }

private:
    Ptr<Texture> texture_;
    Rect rect_;
    Vec2 offset_;
    Size originalSize_;
    bool rotated_ = false;
    std::string name_;
};

} // namespace easy2d
```

**关键优势**：
- 一个纹理图集 → 多个 SpriteFrame（减少纹理切换 = 提升渲染性能）
- SpriteFrame 是轻量引用对象，不创建 Sprite 节点
- 同一 SpriteFrame 可被多个动画共享

#### 3.2 `frame_property.h` - 类型安全的帧属性系统

**设计理念**：
- **强类型枚举**替代字符串键 → 编译期检查
- **optional<T>** 替代裸 variant get → 无运行时异常
- **setCustom(string, any)** → 保留 ANI 不固定数据的灵活扩展能力
- 这是 ANI 系统独有的优势，Cocos 没有等价设计

```cpp
// Easy2D/include/easy2d/animation/frame_property.h
#pragma once
#include <easy2d/core/types.h>
#include <easy2d/core/math_types.h>
#include <easy2d/core/color.h>
#include <variant>
#include <unordered_map>
#include <optional>
#include <any>
#include <string>

namespace easy2d {

// 帧属性键 - 强类型枚举
enum class FramePropertyKey : uint32_t {
    // 事件触发
    SetFlag             = 0x0001,   // int: 关键帧回调索引
    PlaySound           = 0x0002,   // string: 音效路径

    // 变换属性
    ImageRate           = 0x0010,   // Vec2: 缩放比例
    ImageRotate         = 0x0011,   // float: 旋转角度（度）
    ImageOffset         = 0x0012,   // Vec2: 额外位置偏移

    // 视觉效果
    BlendLinearDodge    = 0x0020,   // bool: 线性减淡
    BlendAdditive       = 0x0021,   // bool: 加法混合
    ColorTint           = 0x0022,   // Color: RGBA 颜色

    // 控制标记
    Interpolation       = 0x0030,   // bool: 启用插值

    // 用户自定义区间 (0x1000+)
    UserDefined         = 0x1000,
};

using FramePropertyValue = std::variant<
    bool, int, float, std::string, Vec2, Color, std::vector<int>
>;

// 单帧属性集合
class FramePropertySet {
public:
    void set(FramePropertyKey key, FramePropertyValue value);
    void setCustom(const std::string& key, std::any value);

    template<typename T>
    std::optional<T> get(FramePropertyKey key) const;

    template<typename T>
    T getOr(FramePropertyKey key, const T& defaultValue) const;

    std::optional<std::any> getCustom(const std::string& key) const;

    bool has(FramePropertyKey key) const;
    bool hasCustom(const std::string& key) const;
    bool empty() const;
    void clear();

    // 链式API
    FramePropertySet& withSetFlag(int index);
    FramePropertySet& withPlaySound(const std::string& path);
    FramePropertySet& withImageRate(const Vec2& scale);
    FramePropertySet& withImageRotate(float degrees);
    FramePropertySet& withColorTint(const Color& color);
    FramePropertySet& withInterpolation(bool enabled = true);
    FramePropertySet& withBlendLinearDodge(bool enabled = true);

    using PropertyMap = std::unordered_map<FramePropertyKey, FramePropertyValue>;
    const PropertyMap& properties() const { return properties_; }

private:
    PropertyMap properties_;
    std::unordered_map<std::string, std::any> customProperties_;
};

} // namespace easy2d
```

#### 3.3 `animation_frame.h` - 单帧数据

```cpp
// Easy2D/include/easy2d/animation/animation_frame.h
#pragma once
#include <easy2d/animation/sprite_frame.h>
#include <easy2d/animation/frame_property.h>

namespace easy2d {

// 单帧数据 - 借鉴 Cocos AnimationFrame，引用 SpriteFrame 而非直接持有纹理
struct AnimationFrame {
    // ------ 核心数据 ------
    Ptr<SpriteFrame> spriteFrame;       // ★ 引用 SpriteFrame（Cocos 模式）
    std::string      texturePath;       // 原始路径（用于解析时定位资源）
    int              textureIndex = 0;  // 图集索引
    Vec2             offset;            // 位置偏移
    float            delay = 100.0f;    // 帧延迟(ms)

    // ------ 不固定数据 ------
    FramePropertySet properties;        // ANI Flag 系统（类型安全版）

    // ------ 便捷方法 ------
    bool hasTexture() const;
    bool hasInterpolation() const;
    Vec2  getEffectiveScale() const;
    float getEffectiveRotation() const;
    Color getEffectiveColor() const;
};

} // namespace easy2d
```

#### 3.4 `animation_clip.h` - 动画片段（纯数据，可复用）★借鉴 Cocos

**关键改进**：AnimationClip 是**纯数据对象**，不包含任何播放逻辑。
一份 AnimationClip 可以被多个 AnimationNode 同时使用（Cocos 的核心设计理念）。

```cpp
// Easy2D/include/easy2d/animation/animation_clip.h
#pragma once
#include <easy2d/animation/animation_frame.h>
#include <vector>
#include <string>

namespace easy2d {

class AnimationClip {
public:
    AnimationClip() = default;
    explicit AnimationClip(const std::string& name);

    // 帧管理
    void addFrame(const AnimationFrame& frame);
    void addFrame(AnimationFrame&& frame);
    void insertFrame(size_t index, const AnimationFrame& frame);
    void removeFrame(size_t index);
    void clearFrames();

    const AnimationFrame& getFrame(size_t index) const;
    AnimationFrame& getFrame(size_t index);
    size_t getFrameCount() const { return frames_.size(); }
    bool empty() const { return frames_.empty(); }

    // 全局属性
    FramePropertySet& globalProperties() { return globalProperties_; }
    const FramePropertySet& globalProperties() const { return globalProperties_; }
    bool isLooping() const;
    void setLooping(bool loop);

    // 时间信息
    float getTotalDuration() const;

    // 包围盒
    Size getMaxFrameSize() const;

    // 元数据
    void setName(const std::string& name) { name_ = name; }
    const std::string& getName() const { return name_; }
    void setSourcePath(const std::string& path) { sourcePath_ = path; }
    const std::string& getSourcePath() const { return sourcePath_; }

    // 静态工厂
    static Ptr<AnimationClip> create(const std::string& name = "");

private:
    std::string name_;
    std::string sourcePath_;
    std::vector<AnimationFrame> frames_;
    FramePropertySet globalProperties_;
};

} // namespace easy2d
```

#### 3.5 `ani_parser.h` / `als_parser.h` - 文件解析器

```cpp
// ani_parser.h
namespace easy2d {

using PathResolveCallback = std::function<std::string(const std::string&)>;

struct AniParseResult {
    bool success = false;
    std::string errorMessage;
    Ptr<AnimationClip> clip;
};

class AniParser {
public:
    AniParseResult parse(const std::string& filePath);
    AniParseResult parseFromMemory(const std::string& content,
                                    const std::string& basePath = "");
    void setPathResolver(PathResolveCallback callback);
    void setBasePath(const std::string& basePath);

private:
    PathResolveCallback pathResolver_;
    std::string basePath_;
};

// als_parser.h
struct AlsLayerInfo {
    std::string aniPath;
    int         zOrder = 0;
    Vec2        offset;
};

struct AlsParseResult {
    bool success = false;
    std::string errorMessage;
    std::vector<AlsLayerInfo> layers;
};

class AlsParser {
public:
    AlsParseResult parse(const std::string& filePath);
    void setBasePath(const std::string& basePath);

private:
    std::string basePath_;
};

} // namespace easy2d
```

---

### 第2层 - 缓存层 ★借鉴 Cocos 核心设计

#### 3.6 `sprite_frame_cache.h` - SpriteFrame 全局缓存

借鉴 Cocos 的 `SpriteFrameCache`：全局单例管理所有精灵帧，避免重复创建。

```cpp
// Easy2D/include/easy2d/animation/sprite_frame_cache.h
#pragma once
#include <easy2d/animation/sprite_frame.h>
#include <unordered_map>
#include <mutex>

namespace easy2d {

class SpriteFrameCache {
public:
    static SpriteFrameCache& getInstance();

    // ------ 添加帧 ------
    // 单帧添加
    void addSpriteFrame(Ptr<SpriteFrame> frame, const std::string& name);

    // 从纹理图集批量添加（格式：texturePath + 帧宽高 → 自动切割）
    void addSpriteFramesFromGrid(const std::string& texturePath,
                                  int frameWidth, int frameHeight,
                                  int frameCount = -1);

    // 从ANI文件加载时自动注册
    void addSpriteFrameFromTexture(Ptr<Texture> texture,
                                    const Rect& rect,
                                    const std::string& name);

    // ------ 获取帧 ------
    Ptr<SpriteFrame> getSpriteFrame(const std::string& name) const;

    // 通过路径+索引获取（ANI 格式的定位方式）
    Ptr<SpriteFrame> getOrCreateFromFile(const std::string& texturePath,
                                          int index = 0);

    // ------ 缓存管理 ------
    bool has(const std::string& name) const;
    void removeSpriteFrame(const std::string& name);
    void removeUnusedSpriteFrames();
    void clear();
    size_t count() const;

    // ------ 统计 ------
    void printStats() const;

private:
    SpriteFrameCache() = default;
    mutable std::mutex mutex_;
    std::unordered_map<std::string, Ptr<SpriteFrame>> frames_;
};

#define E2D_SPRITE_FRAME_CACHE() ::easy2d::SpriteFrameCache::getInstance()

} // namespace easy2d
```

#### 3.7 `animation_cache.h` - AnimationClip 全局缓存

借鉴 Cocos 的 `AnimationCache`：同一个 ANI 文件只解析一次，后续直接复用数据。

```cpp
// Easy2D/include/easy2d/animation/animation_cache.h
#pragma once
#include <easy2d/animation/animation_clip.h>
#include <unordered_map>
#include <mutex>

namespace easy2d {

class AnimationCache {
public:
    static AnimationCache& getInstance();

    // ------ 加载与获取（核心API）------
    // 从文件加载（自动缓存），已缓存则直接返回
    Ptr<AnimationClip> loadClip(const std::string& aniFilePath);

    // 从缓存获取（不触发加载）
    Ptr<AnimationClip> getClip(const std::string& name) const;

    // 手动添加
    void addClip(Ptr<AnimationClip> clip, const std::string& name);

    // ------ 缓存管理 ------
    bool has(const std::string& name) const;
    void removeClip(const std::string& name);
    void removeUnusedClips();
    void clear();
    size_t count() const;

    // ------ 路径配置 ------
    void setPathResolver(PathResolveCallback resolver);

    // ------ 统计 ------
    void printStats() const;

private:
    AnimationCache() = default;
    mutable std::mutex mutex_;
    std::unordered_map<std::string, Ptr<AnimationClip>> clips_;
    PathResolveCallback pathResolver_;
};

#define E2D_ANIMATION_CACHE() ::easy2d::AnimationCache::getInstance()

} // namespace easy2d
```

**使用示例（体现复用优势）**：
```cpp
// 加载一次，多处复用 —— Cocos 核心理念
auto clip = E2D_ANIMATION_CACHE().loadClip("effects/explosion.ani");

// 10个爆炸特效共享同一份 AnimationClip 数据
for (int i = 0; i < 10; i++) {
    auto node = AnimationNode::create(clip);  // 只是引用数据，不拷贝
    node->setPosition(positions[i]);
    node->play();
    scene->addChild(node);
}
```

---

### 第3层 - 控制层

#### 3.8 `animation_controller.h` - 播放控制器

借鉴 Cocos Creator 的 `AnimationState`：纯播放逻辑，不持有渲染资源。

```cpp
// Easy2D/include/easy2d/animation/animation_controller.h
#pragma once
#include <easy2d/animation/animation_clip.h>
#include <functional>

namespace easy2d {

enum class AnimPlayState : uint8_t { Stopped, Playing, Paused };

class AnimationController {
public:
    // 回调类型
    using FrameChangeCallback  = std::function<void(size_t oldIdx, size_t newIdx,
                                                     const AnimationFrame& frame)>;
    using KeyframeCallback     = std::function<void(int flagIndex)>;
    using SoundTriggerCallback = std::function<void(const std::string& path)>;
    using CompletionCallback   = std::function<void()>;

    AnimationController();

    // 绑定数据
    void setClip(Ptr<AnimationClip> clip);
    Ptr<AnimationClip> getClip() const { return clip_; }

    // 播放控制
    void play();
    void pause();
    void resume();
    void stop();
    void reset();

    // 帧控制
    void setFrameIndex(size_t index);
    void nextFrame();
    void prevFrame();

    // 核心更新
    void update(float dt);

    // 状态查询
    AnimPlayState getState() const { return state_; }
    bool isPlaying() const { return state_ == AnimPlayState::Playing; }
    bool isPaused()  const { return state_ == AnimPlayState::Paused; }
    bool isStopped() const { return state_ == AnimPlayState::Stopped; }

    size_t getCurrentFrameIndex() const { return currentFrameIndex_; }
    size_t getTotalFrames() const;
    const AnimationFrame& getCurrentFrame() const;

    float getPlaybackSpeed() const { return playbackSpeed_; }
    void  setPlaybackSpeed(float speed) { playbackSpeed_ = speed; }

    bool isLooping() const;
    void setLooping(bool loop);

    // 插值
    float getInterpolationFactor() const { return interpolationFactor_; }
    bool  isInterpolating() const { return interpolating_; }

    // 回调
    void setFrameChangeCallback(FrameChangeCallback cb);
    void setKeyframeCallback(KeyframeCallback cb);
    void setSoundTriggerCallback(SoundTriggerCallback cb);
    void setCompletionCallback(CompletionCallback cb);

private:
    Ptr<AnimationClip> clip_;
    AnimPlayState state_ = AnimPlayState::Stopped;
    size_t currentFrameIndex_ = 0;
    float  accumulatedTime_   = 0.0f;
    float  playbackSpeed_     = 1.0f;
    bool   loopOverride_      = false;
    bool   hasLoopOverride_   = false;
    bool   interpolating_     = false;
    float  interpolationFactor_ = 0.0f;

    FrameChangeCallback  onFrameChange_;
    KeyframeCallback     onKeyframe_;
    SoundTriggerCallback onSoundTrigger_;
    CompletionCallback   onComplete_;

    void advanceFrame(size_t newIndex);
    void processFrameProperties(const AnimationFrame& frame);
};

} // namespace easy2d
```

#### 3.9 `interpolation_engine.h` - 插值引擎

```cpp
// Easy2D/include/easy2d/animation/interpolation_engine.h
#pragma once
#include <easy2d/animation/animation_frame.h>

namespace easy2d {

struct InterpolatedProperties {
    Vec2  position;
    Vec2  scale;
    float rotation;
    Color color;
};

enum class InterpolationCurve : uint8_t {
    Linear, EaseIn, EaseOut, EaseInOut
};

class InterpolationEngine {
public:
    // 核心插值计算
    static InterpolatedProperties interpolate(
        const AnimationFrame& from,
        const AnimationFrame& to,
        float t,
        InterpolationCurve curve = InterpolationCurve::Linear);

    // 单属性插值
    static Vec2  lerpPosition(const AnimationFrame& from, const AnimationFrame& to, float t);
    static Vec2  lerpScale(const AnimationFrame& from, const AnimationFrame& to, float t);
    static float lerpRotation(const AnimationFrame& from, const AnimationFrame& to, float t);
    static Color lerpColor(const AnimationFrame& from, const AnimationFrame& to, float t);

    // 曲线函数
    static float applyCurve(float t, InterpolationCurve curve);
};

} // namespace easy2d
```

---

### 第4层 - 渲染层

#### 3.10 `frame_renderer.h` - 帧渲染器

**核心改进**：原始系统 N 帧 = N 个 Sprite 子节点 → 新设计单渲染器 + SpriteFrame 引用

```cpp
// Easy2D/include/easy2d/animation/frame_renderer.h
#pragma once
#include <easy2d/animation/animation_frame.h>
#include <easy2d/animation/sprite_frame.h>
#include <easy2d/animation/interpolation_engine.h>
#include <easy2d/graphics/render_backend.h>
#include <vector>

namespace easy2d {

class FrameRenderer {
public:
    // 预加载：解析所有帧的 SpriteFrame（通过 SpriteFrameCache）
    bool preloadFrames(const std::vector<AnimationFrame>& frames);
    void releaseFrames();

    // 渲染当前帧
    void renderFrame(RenderBackend& renderer,
                     const AnimationFrame& frame,
                     size_t frameIndex,
                     const glm::mat4& worldTransform,
                     float nodeOpacity,
                     const Color& tintColor,
                     bool flipX, bool flipY);

    // 渲染插值帧
    void renderInterpolated(RenderBackend& renderer,
                            const AnimationFrame& fromFrame,
                            size_t fromIndex,
                            const InterpolatedProperties& props,
                            const glm::mat4& worldTransform,
                            float nodeOpacity,
                            const Color& tintColor,
                            bool flipX, bool flipY);

    // 混合模式
    void applyBlendMode(RenderBackend& renderer, const FramePropertySet& props);

    // 查询
    Ptr<SpriteFrame> getSpriteFrame(size_t frameIndex) const;
    Size getMaxFrameSize() const { return maxFrameSize_; }

private:
    std::vector<Ptr<SpriteFrame>> spriteFrames_;  // 按帧索引的 SpriteFrame 引用
    Size maxFrameSize_;
};

} // namespace easy2d
```

---

### 第5层 - 事件层

#### 3.11 `animation_event.h`

```cpp
namespace easy2d {

enum class AnimationEventType : uint32_t {
    FrameChanged   = 0x2001,
    KeyframeHit    = 0x2002,
    SoundTrigger   = 0x2003,
    AnimationStart = 0x2004,
    AnimationEnd   = 0x2005,
    AnimationLoop  = 0x2006,
};

struct AnimationEvent {
    AnimationEventType type;
    size_t frameIndex = 0;
    size_t previousFrameIndex = 0;
    int keyframeFlag = -1;
    std::string soundPath;
    Node* source = nullptr;
};

using AnimationEventCallback    = std::function<void(const AnimationEvent&)>;
using KeyframeHitCallback       = std::function<void(int flagIndex)>;
using AnimationCompleteCallback = std::function<void()>;

} // namespace easy2d
```

---

### 第6层 - 组件层

#### 3.12 `animation_node.h` - 核心动画节点

```cpp
// Easy2D/include/easy2d/animation/animation_node.h
#pragma once
#include <easy2d/scene/node.h>
#include <easy2d/animation/animation_clip.h>
#include <easy2d/animation/animation_controller.h>
#include <easy2d/animation/frame_renderer.h>
#include <easy2d/animation/animation_event.h>

namespace easy2d {

class AnimationNode : public Node {
public:
    AnimationNode();
    ~AnimationNode() override = default;

    // ------ 静态创建（Cocos 风格工厂）------
    static Ptr<AnimationNode> create();
    static Ptr<AnimationNode> create(Ptr<AnimationClip> clip);
    static Ptr<AnimationNode> create(const std::string& aniFilePath);

    // ------ 动画数据 ------
    void setClip(Ptr<AnimationClip> clip);
    Ptr<AnimationClip> getClip() const;
    bool loadFromFile(const std::string& aniFilePath);
    void setPathResolver(PathResolveCallback resolver);

    // ------ 播放控制 ------
    void play();
    void pause();
    void resume();
    void stop();
    void reset();

    bool isPlaying() const;
    bool isPaused() const;
    bool isStopped() const;

    void setPlaybackSpeed(float speed);
    float getPlaybackSpeed() const;
    void setLooping(bool loop);
    bool isLooping() const;

    // ------ 帧控制 ------
    void setFrameIndex(size_t index);
    size_t getCurrentFrameIndex() const;
    size_t getTotalFrames() const;

    // ------ 事件回调 ------
    void setKeyframeCallback(KeyframeHitCallback callback);
    void setCompletionCallback(AnimationCompleteCallback callback);
    void setFrameChangeCallback(AnimationController::FrameChangeCallback callback);
    void addEventListener(AnimationEventCallback callback);

    // ------ 视觉属性 ------
    void setTintColor(const Color& color);
    Color getTintColor() const { return tintColor_; }
    void setFlipX(bool flip) { flipX_ = flip; }
    void setFlipY(bool flip) { flipY_ = flip; }
    bool isFlipX() const { return flipX_; }
    bool isFlipY() const { return flipY_; }

    // ------ 查询 ------
    Size getMaxFrameSize() const;
    Rect getBoundingBox() const override;

protected:
    void onUpdateNode(float dt) override;
    void onDraw(RenderBackend& renderer) override;
    void generateRenderCommand(std::vector<RenderCommand>& commands, int zOrder) override;
    void onEnter() override;
    void onExit() override;

private:
    AnimationController controller_;
    FrameRenderer       frameRenderer_;
    Color tintColor_ = Colors::White;
    bool  flipX_ = false;
    bool  flipY_ = false;
    std::vector<AnimationEventCallback> eventListeners_;
    PathResolveCallback pathResolver_;

    void setupControllerCallbacks();
    void dispatchEvent(const AnimationEvent& event);
};

} // namespace easy2d
```

#### 3.13 `composite_animation.h` - ALS 复合动画

```cpp
namespace easy2d {

class CompositeAnimation : public Node {
public:
    static Ptr<CompositeAnimation> create();
    static Ptr<CompositeAnimation> create(const std::string& aniFilePath);

    // 加载（自动检测 .als 文件）
    bool loadFromFile(const std::string& aniFilePath);

    // 图层管理
    void addLayer(Ptr<AnimationNode> node, int zOrder = 0);
    void removeLayer(size_t index);
    Ptr<AnimationNode> getLayer(size_t index) const;
    Ptr<AnimationNode> getMainLayer() const;
    size_t getLayerCount() const;

    // 统一播放控制
    void play();
    void pause();
    void resume();
    void stop();
    void reset();
    void setPlaybackSpeed(float speed);
    void setLooping(bool loop);

    // 事件
    void setKeyframeCallback(KeyframeHitCallback callback);
    void setCompletionCallback(AnimationCompleteCallback callback);
    void setPathResolver(PathResolveCallback resolver);

private:
    struct LayerEntry {
        Ptr<AnimationNode> node;
        int zOrder;
    };
    std::vector<LayerEntry> layers_;
    PathResolveCallback pathResolver_;
};

} // namespace easy2d
```

## 四、与现有系统的集成

| 集成点 | 方式 |
|--------|------|
| **TexturePool** | SpriteFrameCache 内部通过 `E2D_TEXTURE_POOL().get()` 获取纹理 |
| **ShaderSystem** | FrameRenderer 的 applyBlendMode 映射到渲染后端混合模式 |
| **AudioEngine** | AnimationNode 在 SoundTrigger 回调中调用 AudioEngine |
| **Action系统** | AnimationNode 继承 Node，可直接 `runAction(new MoveBy(...))` |
| **easy2d.h** | 添加所有 animation 头文件 include |
| **xmake.lua** | 添加 `src/animation/*.cpp` 到构建目标 |

## 五、对比总结

| 维度 | 原始ANI | Cocos2d-x | 新设计（融合） |
|------|---------|-----------|--------------|
| 数据复用 | 每次new新对象 | Animation可复用 | AnimationClip + AnimationCache ✅ |
| 帧抽象 | 直接Sprite对象 | SpriteFrame | SpriteFrame + SpriteFrameCache ✅ |
| 内存 | N帧=N个Sprite | SpriteFrame引用 | 单FrameRenderer + SpriteFrame引用 ✅ |
| 类型安全 | string+variant | 无灵活属性 | enum键 + optional + setCustom ✅ |
| 不固定数据 | Flag系统 ✅ | 无 | FramePropertySet（增强版） ✅ |
| ALS复合 | 内嵌Init ✅ | Action组合 | 独立CompositeAnimation ✅ |
| 全局缓存 | 无 | AnimationCache | AnimationCache + SpriteFrameCache ✅ |
| 插值 | 线性硬编码 | 无 | 独立引擎 + 多曲线 ✅ |

## 六、实现顺序（7个阶段）

1. **阶段一 - 数据基础**：`sprite_frame.h/cpp` → `frame_property.h/cpp` → `animation_frame.h/cpp` → `animation_clip.h/cpp`
2. **阶段二 - 缓存系统**：`sprite_frame_cache.h/cpp` → `animation_cache.h/cpp`
3. **阶段三 - 解析器**：`ani_parser.h/cpp` → `als_parser.h/cpp`
4. **阶段四 - 控制层**：`interpolation_engine.h/cpp` → `animation_controller.h/cpp`
5. **阶段五 - 渲染层**：`frame_renderer.h/cpp`
6. **阶段六 - 事件+组件层**：`animation_event.h` → `animation_node.h/cpp` → `composite_animation.h/cpp`
7. **阶段七 - 集成**：修改 `easy2d.h` + `xmake.lua`

## 七、关键文件路径

需要修改的现有文件：
- `Easy2D/include/easy2d/easy2d.h` - 添加 animation includes
- `xmake.lua` - 添加 animation 源文件到构建

需要创建的新文件（共28个）：
- `Easy2D/include/easy2d/animation/` 下 14 个 `.h` 文件
- `Easy2D/src/animation/` 下 14 个 `.cpp` 文件

参考文件：
- `de/Animation.h` + `de/Animation.cpp` - 原始 ANI 设计
- `Easy2D/include/easy2d/scene/node.h` - Node 基类接口
- `Easy2D/include/easy2d/scene/sprite.h` - Sprite 渲染参考
- `Easy2D/include/easy2d/graphics/texture_pool.h` - TexturePool 接口
- `Easy2D/include/easy2d/graphics/render_backend.h` - 渲染后端接口

## 八、验证方案

1. **编译验证**：`xmake build` 确保所有新文件编译通过
2. **单元测试**：
   - FramePropertySet 类型安全的 set/get/getOr 测试
   - SpriteFrame 创建和缓存测试
   - AnimationCache 加载/复用/清理测试
   - AnimationController 帧推进 + 循环 + 回调测试
   - InterpolationEngine 插值正确性测试
3. **集成测试**（创建 demo）：
   - 从 ANI 文件加载并播放动画
   - 同一 AnimationClip 被多个 AnimationNode 共享
   - 关键帧回调、音效触发
   - ALS 复合动画多层同步
   - 与 Action 系统协同（MoveBy + AnimationNode）
4. **性能验证**：
   - 100个相同动画实例的内存对比（原始 vs 新系统）
   - AnimationCache 命中率统计
   - SpriteFrameCache 复用率统计
